---
title: "Method Comparison"
author: "Vivien Wiltzsch & Klaudia Adamowicz"
date: "2024-03-18"
output: 
  html_document:
    toc : true
    toc_depth: 2
    number_sections: true
---

## Setup 
This section loads the necessary libraries for the analysis and sets some initial parameters such as color mapping and random seed for reproducibility.

```{r setup, include=FALSE}
#BiocManager::install("ComplexUpset")
library_names <- c("readr", "ggplot2", "dplyr", "tidyr", "stringr", "data.table",
                   "purrr", "forcats", "patchwork", "matrixStats", "gridExtra", "ComplexUpset")

for (lib in library_names) {
  library(lib, character.only = TRUE)
}

# set random number seed
seed = 27
set.seed(seed)


# Define color mapping for Fractions
fraction_colors <- c("AI" = "royalblue", "AS" = "palegreen3", "single" = "coral")

```

## Data Loading
Here, the raw data files are loaded into R. This includes the main dataset and the metadata file, which will be used for subsequent analysis steps.

```{r load_data}
# Adjust path as necessary for your file locations
dataset_unsorted <- fread("data/report.pg_matrix.tsv")[, ID := .I]
meta_data <- fread("data/meta_data.csv")
```

## Data Preperation

### Data Trimming
The column names of the loaded dataset are cleaned up in this step. This involves removing specific prefixes and suffixes to standardize the column names, making them easier to work with.

```{r prepare_data}
# Clean up column names in dataset
# Remove specific prefix and suffix from column names
prefix <- "/mnt/ag_proteomik/shared_worktmp/20240126_CaGe_Knochenextraktion ohne Label_Thess/Knochenextrakte_"
suffix <- "_Slot.*"

names(dataset_unsorted) <- sub(suffix, "", sub(prefix, "", names(dataset_unsorted)))
```

### Data Sorting
In this section, the metadata is prepared for sorting, and the main dataset's columns are reordered based on this sorted metadata. This ensures that the dataset columns follow a meaningful order, aligning with the metadata.

```{r sort_data}
# Prepare meta_data for sorting
# Extract numerical part from 'Column' for sorting purposes
meta_data[, M_value := as.numeric(sub("M", "", sub("-.*", "", Column)))]

# Define custom order for Buffer_type and apply it
buffer_order <- c("AS", "AI", "AS1", "AI1", "AI2", "AS2", "single")
meta_data[, Buffer_name := factor(Buffer_name, levels = buffer_order)]

# Sort meta_data based on multiple criteria
ordered_meta_data <- meta_data[order(M_value, Repl_Techn, Repl_Biol, Buffer_name)]

# Sort column names in dataset_unsorted
descr_columns <- names(dataset_unsorted)[!names(dataset_unsorted) %in% ordered_meta_data$Column]
new_order <- c(descr_columns, ordered_meta_data$Column)
dataset_sorted <- dataset_unsorted[, ..new_order]
```

### Data Transformation and Merging
The sorted dataset is transformed into a long format, which is more suitable for certain types of analysis. Following this, the dataset is merged with the metadata, enriching it with additional information necessary for analysis.

```{r}
# Melt dataset_sorted into a long format
dataset_long <- melt(dataset_sorted, 
                     id.vars = descr_columns, 
                     variable.name = "Sample.ID", 
                     value.name = "maxLfQ_intensities")

# Merge dataset_long with meta_data
dataset_merged <- merge(dataset_long, meta_data, by.x = "Sample.ID", by.y = "Column", all.x = TRUE)

write_tsv(dataset_merged, "report.pg_matrix_long.tsv")
```

## Data Analysis

```{r}
# Count the number of non-NA maxLfQ_intensities for each Sample.ID within each Method
dataset_count <- dataset_merged[!is.na(maxLfQ_intensities), .(Protein_Count = .N), by = .(Method, Sample.ID, Buffer_type)]

# Set the order of Sample.ID in dataset_count to match the order in ordered_meta_data$Column
dataset_count$Sample.ID <- factor(dataset_count$Sample.ID, levels = ordered_meta_data$Column)

# Create the barplot
ggplot(dataset_count, aes(x = Sample.ID, y = Protein_Count, fill = Buffer_type)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  facet_wrap(~ Method, scales = "free_x") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Number of Quantified Proteins per Sample, by Method",
       y = "Number of Quantified Proteins", x = "Sample ID", fill = "Buffer Type") +
  scale_fill_manual(values = fraction_colors)
```

```{r}
# Create the barplot 
d1 <- dataset_count[dataset_count$Method %in% c("1step", "1step+", "2step"),] 
p1 <- ggplot(d1, aes(x = Sample.ID, y = Protein_Count, fill = Buffer_type)) +   geom_bar(stat = "identity", position = position_dodge()) +   
  facet_grid(. ~ Method, scales = "free_x", space = "free") +  facet_wrap(~Method, scales = "free_x") +   theme(axis.text.x = element_text(angle = 45, hjust = 1)) + labs(title = "Number of Quantified Proteins per Sample, by Method",  y = "Number of Quantified Proteins", x = "Sample ID", fill = "Buffer Type")  + labs( title = "", y = "", x = "", fill = "Buffer Type") +   force_panelsizes(cols = c(0.5,0.5,1.5))  +  scale_fill_manual(values = fraction_colors)

d2 <- dataset_count[dataset_count$Method %in% c("2step+", "4step"),] 
p2 <-ggplot(d2, aes(x = Sample.ID, y = Protein_Count, fill = Buffer_type)) +   geom_bar(stat = "identity", position = position_dodge()) +   
  facet_grid(. ~ Method, scales = "free_x", space = "free") +   facet_wrap(~Method, scales = "free_x") +   theme(axis.text.x = element_text(angle = 45, hjust = 1)) +   labs(title = "Number of Quantified Proteins per Sample, by Method", y = "Number of Quantified Proteins", x = "Sample ID", fill = "Buffer Type") + labs( title = "", y = "", x = "", fill = "Buffer Type") +   force_panelsizes(cols = c(1.5, 1))  +  scale_fill_manual(values = fraction_colors)

final_p <- ggarrange(p1, p2, ncol = 1, common.legend = TRUE, legend = "right") 
final_p <- annotate_figure(final_p, top = "Number of Quantified Proteins per Sample by Method", left = "Number of Quantified Proteins", bottom = "Sample ID")
print(final_p)
```



```{r}
# Filter dataset for Repl_Techn == 1 before analysis
dataset_filtered <- dataset_merged[Repl_Techn == 1 & !is.na(maxLfQ_intensities)]

# Calculate the total number of unique proteins per method for Repl_Techn == 1
unique_protein_count <- dataset_filtered[, .(Count = uniqueN(ID)), by = .(Method)]
unique_protein_count[, Source := "Total_Quantified_Proteins"]

# Calculate proteins in at least 3 out of 4 biological replicates per method for Repl_Techn == 1
proteins_in_3_of_4_repl_count <- dataset_filtered[, .(Unique_Repl_Biol_Count = uniqueN(Repl_Biol)), by = .(Method, ID)]
proteins_in_3_of_4_repl_count <- proteins_in_3_of_4_repl_count[Unique_Repl_Biol_Count >= 3, .(Count = .N), by = .(Method)]
proteins_in_3_of_4_repl_count[, Source := "Total_Proteins_3_4_Repls"]

# Combine both counts for plotting
combined_counts <- rbind(unique_protein_count, proteins_in_3_of_4_repl_count)

# Create the barplot
ggplot(combined_counts, aes(x = Method, y = Count, fill = Source)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9)) +
  geom_text(aes(label = Count), vjust = -0.3, position = position_dodge(width = 0.9), size = 3) +
  labs(title = "Protein Counts per Method (Technical Replicate 1)", 
       y = "No. of quantified proteins", 
       x = "Method", 
       fill = "Quantified Proteins") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_y_continuous(breaks = seq(0, 6000, by = 1000), limits = c(0, 6000)) +
  scale_fill_manual(values = c("Total_Quantified_Proteins" = "#4D8DB4", "Total_Proteins_3_4_Repls" = "#005B7F"),
                    labels = c("3 of 4 biol. Replicates", "Total"))

```

```{r}
# Combine Method and Repl_Techn
dataset_merged$Method_Techn <- paste(dataset_merged$Method, dataset_merged$Repl_Techn, sep = "_")

# Calculate the total number of unique proteins per combined Method and Repl_Techn
unique_protein_count <- dataset_merged[!is.na(maxLfQ_intensities), .(Count = uniqueN(ID)), by = .(Method_Techn)]
unique_protein_count[, Source := "Total_Quantified_Proteins"]

# Calculate proteins in at least 3 out of 4 biological replicates per combined Method and Repl_Techn
proteins_in_3_of_4_repl_count <- dataset_merged[!is.na(maxLfQ_intensities), .(Unique_Repl_Biol_Count = uniqueN(Repl_Biol)), by = .(Method_Techn, ID)]
proteins_in_3_of_4_repl_count <- proteins_in_3_of_4_repl_count[Unique_Repl_Biol_Count >= 3, .(Count = .N), by = .(Method_Techn)]
proteins_in_3_of_4_repl_count[, Source := "Total_Proteins_3_4_Repls"]

# Combine both counts for plotting
combined_counts <- rbind(unique_protein_count, proteins_in_3_of_4_repl_count)

# Create the barplot
ggplot(combined_counts, aes(x = Method_Techn, y = Count, fill = Source)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9)) +
  geom_text(aes(label = Count), vjust = -0.3, position = position_dodge(width = 0.9), size = 3) +
  labs(title = "Protein Counts per Combined Method and Technical Replicate", 
       y = "Number of Quantified Proteins", 
       x = "Method and Technical Replicate", 
       fill = "Quantified Proteins") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_y_continuous(breaks = seq(0, max(combined_counts$Count), by = 1000)) +
  scale_fill_manual(values = c("Total_Quantified_Proteins" = "#4D8DB4", "Total_Proteins_3_4_Repls" = "#005B7F"),
                    labels = c("3 of 4 Biol. Replicates", "Total"))
```



```{r}

# Filter dataset for "2step+" method
dataset_2step_plus <- dataset_merged[Method == "2step+" & !is.na(maxLfQ_intensities)]

# Filter IDs present in at least 3 out of 4 biological replicates
filtered_ids <- dataset_2step_plus[, .(Unique_Repl_Biol_Count = uniqueN(Repl_Biol)), by = .(ID)]
filtered_ids <- filtered_ids[Unique_Repl_Biol_Count >= 3]
dataset_2step_plus <- merge(filtered_ids[, .(ID)], dataset_2step_plus, by = "ID")

binary_presence <- dataset_2step_plus %>%
  distinct(ID, Repl_Techn) %>%
  pivot_wider(names_from = Repl_Techn, values_from = Repl_Techn, 
              values_fill = list(Repl_Techn = 0), 
              values_fn = list(Repl_Techn = function(x) 1))  %>%
  tibble::column_to_rownames(var = "ID")

binary_presence$all <- 1
binary_presence <- binary_presence[, c(4,3,2,1,5)]

ComplexUpset::upset(data=binary_presence, 
                    intersect=names(binary_presence), name="Technical Replicates", 
                     wrap=TRUE,
                    base_annotations=list(
                        'Intersection size'=intersection_size(
                            text=list(
                                size = 2.5
                            )
                        )
                    ),
                    set_sizes=(
                        upset_set_size()
                        + geom_text(aes(label=..count..), hjust=1.1, stat='count')
                        + annotate(geom='text', label='@', x='Count', y=850, color='white', size=3)
                        + expand_limits(y=7000)
                    ),
                    sort_sets=FALSE,
                    queries=list(
                        upset_query(
                            intersect = names(binary_presence),
                            color='darkred',
                            fill='darkred',
                            only_components=c('intersections_matrix', 'Intersection size')
                        ),
                        upset_query(
                            set='all',
                            fill='orange'
                        ), 
                        upset_query(intersect = c("all", "1"), color = "darkgreen", only_components=c('intersections_matrix')),
                        upset_query(intersect = c("all", "2"), color = "darkgreen", only_components=c('intersections_matrix')),
                        upset_query(intersect = c("all", "3"), color = "darkgreen", only_components=c('intersections_matrix')),
                        upset_query(intersect = c("all", "4"), color = "darkgreen", only_components=c('intersections_matrix'))
                    ),
                    sort_intersections_by='degree') + ggtitle('Intersection of Quantified Proteins in 2Step+')

```

```{r}
# Filter dataset for Repl_Techn == 1 before analysis
dataset_filtered <- dataset_merged[!is.na(maxLfQ_intensities)]

# Calculate the total number of unique proteins per method for Repl_Techn == 1
unique_protein_count <- dataset_filtered[, .(Count = uniqueN(ID)), by = .(Method)]
unique_protein_count[, Source := "Total_Quantified_Proteins"]

# Calculate proteins in at least 3 out of 4 biological replicates per method for Repl_Techn == 1
proteins_in_3_of_4_repl_count <- dataset_filtered[, .(Unique_Repl_Biol_Count = uniqueN(Repl_Biol)), by = .(Method, ID)]
proteins_in_3_of_4_repl_count <- proteins_in_3_of_4_repl_count[Unique_Repl_Biol_Count >= 3, .(Count = .N), by = .(Method)]
proteins_in_3_of_4_repl_count[, Source := "Total_Proteins_3_4_Repls"]

# Combine both counts for plotting
combined_counts <- rbind(unique_protein_count, proteins_in_3_of_4_repl_count)

# Create the barplot
ggplot(combined_counts, aes(x = Method, y = Count, fill = Source)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9)) +
  geom_text(aes(label = Count), vjust = -0.3, position = position_dodge(width = 0.9), size = 3) +
  labs(title = "Protein Counts per Method (Technical Replicate 1)", 
       y = "No. of quantified proteins", 
       x = "Method", 
       fill = "Quantified Proteins") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_y_continuous(breaks = seq(0, 6000, by = 1000), limits = c(0, 6000)) +
  scale_fill_manual(values = c("Total_Quantified_Proteins" = "#4D8DB4", "Total_Proteins_3_4_Repls" = "#005B7F"),
                    labels = c("3 of 4 biol. Replicates", "Total"))
```


```{r}

# Filter dataset for Repl_Techn == 1 and not NA in maxLfQ_intensities
dataset_techn_1 <- dataset_merged[Repl_Techn == 1 & !is.na(maxLfQ_intensities)]

# Filter IDs present in at least 3 out of 4 biological replicates
filtered_ids <- dataset_techn_1[, .(Unique_Repl_Biol_Count = uniqueN(Repl_Biol)), by = .(Method, ID)]
filtered_ids <- filtered_ids[Unique_Repl_Biol_Count >= 3]
dataset_techn_1 <- merge(filtered_ids[, .(Method, ID)], dataset_techn_1, by = c("Method", "ID"))

# Creating a binary presence table for each protein ID across methods
binary_presence <- dataset_techn_1 %>%
  distinct(ID, Method) %>%
  pivot_wider(names_from = Method, values_from = Method, 
              values_fill = list(Method = 0), 
              values_fn = list(Method = function(x) 1)) %>%
  tibble::column_to_rownames(var = "ID")

binary_presence$all <- 1
binary_presence <- binary_presence[, c("4step", "2step+", "2step", "1step+", "1step", "all")]

ComplexUpset::upset(data=binary_presence, 
                    intersect=names(binary_presence), name="Methods", 
                     wrap=TRUE,
                    base_annotations=list(
                        'Intersection size'=intersection_size(
                            text=list(
                                size = 2.5
                            )
                        )
                    ),
                    set_sizes=(
                        upset_set_size()
                        + geom_text(aes(label=..count..), hjust=1.1, stat='count')
                        + annotate(geom='text', label='@', x='Count', y=850, color='white', size=3)
                        + expand_limits(y=7000)
                    ),
                    sort_sets=FALSE,
                    queries=list(
                        upset_query(
                            intersect = names(binary_presence),
                            color='darkred',
                            fill='darkred',
                            only_components=c('intersections_matrix', 'Intersection size')
                        ),
                        upset_query(
                            set='all',
                            fill='orange'
                        ), 
                        upset_query(intersect = c("all", "1step"), color = "darkgreen", only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("all", "1step+"), color = "darkgreen", only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("all", "2step"), color = "darkgreen", only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("all", "2step+"), color = "darkgreen", only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("all", "4step"), color = "darkgreen", only_components=c('intersections_matrix', 'Intersection size'))
                    ),
                    sort_intersections_by='cardinality') + ggtitle('Intersection of Quantified Proteins in Methods')
```

```{r}
library(VennDiagram) 

# Filter the dataset for the specified methods and technical replicate 1
#filtered_dataset <- dataset_merged %>%
filtered_dataset <- dataset_techn_1 %>%
  filter(Method %in% c("2step", "2step+", "4step") & Repl_Techn == 1 & !is.na(maxLfQ_intensities))
  

# Get unique IDs for each method
ids_2step <- unique(filtered_dataset$ID[filtered_dataset$Method == "2step"])
ids_2step_plus <- unique(filtered_dataset$ID[filtered_dataset$Method == "2step+"])
ids_4step <- unique(filtered_dataset$ID[filtered_dataset$Method == "4step"])

# Define a list with IDs for each method
list_of_ids <- list(
  "2step" = ids_2step,
  "2step+" = ids_2step_plus,
  "4step" = ids_4step
)

# Create the Venn diagram
venn.plot <- venn.diagram(
  x = list_of_ids,
  category.names = c("2step", "2step+", "4step"),
  output = TRUE,
  filename = NULL
)

# Plotting
grid.draw(venn.plot)

```

```{r}
# Filter dataset for technical replicate 1 and not NA in maxLfQ_intensities
dataset_filtered <- dataset_merged[Method %in% c("2step", "2step+", "4step") & Repl_Techn == 1 & !is.na(maxLfQ_intensities), ]

# Get unique IDs for each method
ids_2step <- unique(dataset_filtered$ID[dataset_filtered$Method == "2step"])
ids_2step_plus <- unique(dataset_filtered$ID[dataset_filtered$Method == "2step+"])
ids_4step <- unique(dataset_filtered$ID[dataset_filtered$Method == "4step"])

# Find exclusive IDs for each method
exclusive_ids_2step <- setdiff(ids_2step, c(ids_2step_plus, ids_4step))
exclusive_ids_2step_plus <- setdiff(ids_2step_plus, c(ids_2step, ids_4step))
exclusive_ids_4step <- setdiff(ids_4step, c(ids_2step, ids_2step_plus))

# Create dataframes for exclusive IDs
exclusive_df_2step <- dataset_filtered[dataset_filtered$ID %in% exclusive_ids_2step, ]
exclusive_df_2step_plus <- dataset_filtered[dataset_filtered$ID %in% exclusive_ids_2step_plus, ]
exclusive_df_4step <- dataset_filtered[dataset_filtered$ID %in% exclusive_ids_4step, ]

# Combine into one dataframe
exclusive_df_combined <- rbind(exclusive_df_2step, exclusive_df_2step_plus, exclusive_df_4step)

exclusive_df_refined <- exclusive_df_combined %>%
  select(Protein.Ids, Protein.Names, Genes, ID, First.Protein.Description, Method) %>%
  distinct()
```

```{r}
library(VennDiagram) 

# Filter the dataset for the specified methods and technical replicate 1
filtered_dataset <- dataset_merged %>%
  filter(Method %in% c("2step", "2step+", "4step") & Repl_Techn == 1 & !is.na(maxLfQ_intensities))

# Get unique IDs for each method
ids_2step <- unique(filtered_dataset$Genes[filtered_dataset$Method == "2step"])
ids_2step_plus <- unique(filtered_dataset$Genes[filtered_dataset$Method == "2step+"])
ids_4step <- unique(filtered_dataset$Genes[filtered_dataset$Method == "4step"])

# Define a list with IDs for each method
list_of_ids <- list(
  "2step" = ids_2step,
  "2step+" = ids_2step_plus,
  "4step" = ids_4step
)

# Create the Venn diagram
venn.plot <- venn.diagram(
  x = list_of_ids,
  category.names = c("2step", "2step+", "4step"),
  output = TRUE,
  filename = NULL
)

# Plotting
grid.draw(venn.plot)
```

Check intersection between groups

```{r}
dataset_techn_1 <- dataset_merged[Repl_Techn == 1 & !is.na(maxLfQ_intensities)]

groups_1step <- unique(dataset_techn_1[dataset_techn_1$Method == "1step",]$Protein.Ids)
groups_1step_plus <- unique(dataset_techn_1[dataset_techn_1$Method == "1step+",]$Protein.Ids)
groups_2step <- unique(dataset_techn_1[dataset_techn_1$Method == "2step",]$Protein.Ids)
groups_2step_plus <- unique(dataset_techn_1[dataset_techn_1$Method == "2step+",]$Protein.Ids)
groups_4step <- unique(dataset_techn_1[dataset_techn_1$Method == "4step",]$Protein.Ids)

# Create a union of all unique protein groups, removing duplicates
groups_all <- unique(c(groups_1step, groups_1step_plus, groups_2step, groups_2step_plus, groups_4step))

# Function to check full or partial presence
check_presence <- function(group, method_groups) {
  if (group %in% method_groups) {
    return(1)  # Fully present
  } else {
    # Split the group into individual proteins
    proteins <- unlist(strsplit(group, ";"))
    method_proteins <- unlist(strsplit(method_groups, ";"))
    # Calculate proportion of shared proteins
    shared_proteins <- length(intersect(proteins, method_proteins))
    return(min(1, shared_proteins / length(proteins)))  # Partial presence
  }
}

# Prepare the results DataFrame
results <- setNames(data.frame(matrix(ncol = 6, nrow = length(groups_all))), c("Group", "1step", "1step+", "2step", "2step+", "4step"))
results$Group <- groups_all

# Iterate over each group and check for presence in each method
for (i in 1:nrow(results)) {
  results[i, "1step"] <- check_presence(results$Group[i], groups_1step)
  results[i, "1step+"] <- check_presence(results$Group[i], groups_1step_plus)
  results[i, "2step"] <- check_presence(results$Group[i], groups_2step)
  results[i, "2step+"] <- check_presence(results$Group[i], groups_2step_plus)
  results[i, "4step"] <- check_presence(results$Group[i], groups_4step)
}


```


```{r}
# Function to check full or partial presence and return appropriate group
check_presence <- function(group, method_groups) {
  if (group %in% method_groups) {
    return(group)  # Fully present
  } else {
    # Split the group into individual proteins
    proteins <- unlist(strsplit(group, ";"))
    method_proteins_lists <- strsplit(method_groups, ";")
    
    # Find the method group with the highest number of shared proteins
    shared_counts <- sapply(method_proteins_lists, function(m_proteins) length(intersect(proteins, m_proteins)))
    max_shared <- max(shared_counts)
    
    if (max_shared != 0) {
      # Return the method group with the highest shared count
      return(method_groups[which(shared_counts == max_shared)[1]])
    } else {
      return("")  # No shared proteins
    }
  }
}

# Prepare the results DataFrame
results <- setNames(data.frame(matrix(ncol = 6, nrow = length(groups_all))), c("Group", "1step", "1step+", "2step", "2step+", "4step"))
results$Group <- groups_all

# Iterate over each group and check for presence in each method
for (i in 1:nrow(results)) {
  results[i, "1step"] <- check_presence(results$Group[i], groups_1step)
  results[i, "1step+"] <- check_presence(results$Group[i], groups_1step_plus)
  results[i, "2step"] <- check_presence(results$Group[i], groups_2step)
  results[i, "2step+"] <- check_presence(results$Group[i], groups_2step_plus)
  results[i, "4step"] <- check_presence(results$Group[i], groups_4step)
}

# View the results
#print(results)

```


```{r}
# Assuming the method columns are "1step", "1step+", "2step", "2step+", "4step" in both DataFrames
method_columns <- c("1step", "1step+", "2step", "2step+", "4step")

# Rename columns in results_group by adding a suffix (e.g., "_group")
results_group2 <- results_groups %>%
  rename_at(vars(one_of(method_columns)), ~paste0(., "_group"))

combined_results <- merge(results, results_group2, by = "Group")

```


```{r}
filtered_results <- combined_results %>%
  filter(if_any(all_of(method_columns), ~ .x != 1 & .x != 0))
```

```{r}
test <- filtered_dataset[!filtered_dataset$Protein.Ids %in% filtered_results$Group ,]

# Get unique IDs for each method
ids_2step <- unique(test$Genes[test$Method == "2step"])
ids_2step_plus <- unique(test$Genes[test$Method == "2step+"])
ids_4step <- unique(test$Genes[test$Method == "4step"])

# Define a list with IDs for each method
list_of_ids <- list(
  "2step" = ids_2step,
  "2step+" = ids_2step_plus,
  "4step" = ids_4step
)

# Create the Venn diagram
venn.plot <- venn.diagram(
  x = list_of_ids,
  category.names = c("2step", "2step+", "4step"),
  output = TRUE,
  filename = NULL
)

# Plotting
grid.draw(venn.plot)
```

again check between technical replicates for proportions

```{r}
dataset_2step_plus <- dataset_merged[Method == "2step+" & !is.na(maxLfQ_intensities)]

# Filter dataset for method "2step+" and technical replicates
groups_techn_replicates <- lapply(unique(dataset_2step_plus$Repl_Techn), function(tech_rep) {
  unique(dataset_2step_plus[dataset_2step_plus$Method == "2step+" & dataset_2step_plus$Repl_Techn == tech_rep,]$Protein.Ids)
})

# Create a union of all unique protein groups within "2step+" method
groups_all <- unique(unlist(groups_techn_replicates))

# Prepare the results DataFrame
techn_rep_names <- paste0("TechRep", unique(dataset_2step_plus$Repl_Techn))
results <- setNames(data.frame(matrix(ncol = length(techn_rep_names) + 1, nrow = length(groups_all))), c("Group", techn_rep_names))
results$Group <- groups_all

# Check presence across technical replicates
for (i in 1:nrow(results)) {
  for (j in 1:length(groups_techn_replicates)) {
    results[i, j + 1] <- check_presence(results$Group[i], groups_techn_replicates[[j]])
  }
}
```

```{r}
filtered_results2 <- results %>%
  filter(if_any(all_of(names(results)[-1]), ~ .x != 1 & .x != 0))
```

```{r}
# Filter dataset for Repl_Techn == 1 and not NA in maxLfQ_intensities
dataset_techn_1 <- dataset_merged[!is.na(maxLfQ_intensities)]

# Filter IDs present in at least 3 out of 4 biological replicates
filtered_ids <- dataset_techn_1[, .(Unique_Repl_Biol_Count = uniqueN(Repl_Biol)), by = .(Method, ID)]
filtered_ids <- filtered_ids[Unique_Repl_Biol_Count >= 3]
dataset_techn_1 <- merge(filtered_ids[, .(Method, ID)], dataset_techn_1, by = c("Method", "ID"))

# Creating a binary presence table for each protein ID across methods
binary_presence <- dataset_techn_1 %>%
  distinct(ID, Method) %>%
  pivot_wider(names_from = Method, values_from = Method, 
              values_fill = list(Method = 0), 
              values_fn = list(Method = function(x) 1)) %>%
  tibble::column_to_rownames(var = "ID")

binary_presence$all <- 1
binary_presence <- binary_presence[, c("4step", "2step+", "2step", "1step+", "1step", "all")]

ComplexUpset::upset(data=binary_presence, 
                    intersect=names(binary_presence), name="Methods", 
                     wrap=TRUE,
                    base_annotations=list(
                        'Intersection size'=intersection_size(
                            text=list(
                                size = 2.5
                            )
                        )
                    ),
                    set_sizes=(
                        upset_set_size()
                        + geom_text(aes(label=..count..), hjust=1.1, stat='count')
                        + annotate(geom='text', label='@', x='Count', y=850, color='white', size=3)
                        + expand_limits(y=7000)
                    ),
                    sort_sets=FALSE,
                    queries=list(
                        upset_query(
                            intersect = names(binary_presence),
                            color='darkred',
                            fill='darkred',
                            only_components=c('intersections_matrix', 'Intersection size')
                        ),
                        upset_query(
                            set='all',
                            fill='orange'
                        ), 
                        upset_query(intersect = c("all", "1step"), color = "darkgreen", only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("all", "1step+"), color = "darkgreen", only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("all", "2step"), color = "darkgreen", only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("all", "2step+"), color = "darkgreen", only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("all", "4step"), color = "darkgreen", only_components=c('intersections_matrix', 'Intersection size'))
                    ),
                    sort_intersections_by='cardinality') + ggtitle('Intersection of Quantified Proteins in Methods')
```

```{r}
library(VennDiagram) 

# Filter the dataset for the specified methods and technical replicate 1
#filtered_dataset <- dataset_merged %>%
filtered_dataset <- dataset_techn_1  %>%
  filter(Method %in% c("2step", "2step+", "4step") & !is.na(maxLfQ_intensities))

# Get unique IDs for each method
ids_2step <- unique(filtered_dataset$ID[filtered_dataset$Method == "2step"])
ids_2step_plus <- unique(filtered_dataset$ID[filtered_dataset$Method == "2step+"])
ids_4step <- unique(filtered_dataset$ID[filtered_dataset$Method == "4step"])

# Define a list with IDs for each method
list_of_ids <- list(
  "2step" = ids_2step,
  "2step+" = ids_2step_plus,
  "4step" = ids_4step
)

# Create the Venn diagram
venn.plot <- venn.diagram(
  x = list_of_ids,
  category.names = c("2step", "2step+", "4step"),
  output = TRUE,
  filename = NULL
)

# Plotting
grid.draw(venn.plot)
```

## Check Intersection between Buffers

