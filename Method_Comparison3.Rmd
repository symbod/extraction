---
title: "Method Comparison"
author: "Vivien Wiltzsch & Klaudia Adamowicz"
date: "2024-03-18"
output: 
  html_document:
    toc : true
    toc_depth: 2
    number_sections: true
---

## Setup 
This section loads the necessary libraries for the analysis and sets some initial parameters such as color mapping and random seed for reproducibility.

```{r setup, include=FALSE}
#BiocManager::install("ComplexUpset")
library_names <- c("readr", "ggplot2", "dplyr", "tidyr", "stringr", "data.table",
                   "purrr", "forcats", "patchwork", "matrixStats", "gridExtra", "ComplexUpset")

for (lib in library_names) {
  library(lib, character.only = TRUE)
}

# set random number seed
seed = 27
set.seed(seed)


# Define color mapping for Fractions
fraction_colors <- c("AI" = "royalblue", "AS" = "palegreen3", "single" = "coral")

```

## Data Loading
Here, the raw data files are loaded into R. This includes the main dataset and the metadata file, which will be used for subsequent analysis steps.

```{r load_data}
# Adjust path as necessary for your file locations
dataset_unsorted <- fread("data/report.pg_matrix.tsv")[, ID := .I]
meta_data <- fread("data/meta_data.csv")
```

## Data Preperation

### Data Trimming
The column names of the loaded dataset are cleaned up in this step. This involves removing specific prefixes and suffixes to standardize the column names, making them easier to work with.

```{r prepare_data}
# Clean up column names in dataset
# Remove specific prefix and suffix from column names
prefix <- "/mnt/ag_proteomik/shared_worktmp/20240126_CaGe_Knochenextraktion ohne Label_Thess/Knochenextrakte_"
suffix <- "_Slot.*"

names(dataset_unsorted) <- sub(suffix, "", sub(prefix, "", names(dataset_unsorted)))
```

### Data Sorting
In this section, the metadata is prepared for sorting, and the main dataset's columns are reordered based on this sorted metadata. This ensures that the dataset columns follow a meaningful order, aligning with the metadata.

```{r sort_data}
# Prepare meta_data for sorting
# Extract numerical part from 'Column' for sorting purposes
meta_data[, M_value := as.numeric(sub("M", "", sub("-.*", "", Column)))]

# Define custom order for Buffer_type and apply it
buffer_order <- c("AS", "AI", "AS1", "AI1", "AI2", "AS2", "single")
meta_data[, Buffer_name := factor(Buffer_name, levels = buffer_order)]

# Sort meta_data based on multiple criteria
ordered_meta_data <- meta_data[order(M_value, Repl_Techn, Repl_Biol, Buffer_name)]

# Sort column names in dataset_unsorted
descr_columns <- names(dataset_unsorted)[!names(dataset_unsorted) %in% ordered_meta_data$Column]
new_order <- c(descr_columns, ordered_meta_data$Column)
dataset_sorted <- dataset_unsorted[, ..new_order]
```

### Data Transformation and Merging
The sorted dataset is transformed into a long format, which is more suitable for certain types of analysis. Following this, the dataset is merged with the metadata, enriching it with additional information necessary for analysis.

```{r}
# Melt dataset_sorted into a long format
dataset_long <- melt(dataset_sorted, 
                     id.vars = descr_columns, 
                     variable.name = "Sample.ID", 
                     value.name = "maxLfQ_intensities")

# Merge dataset_long with meta_data
dataset_merged <- merge(dataset_long, meta_data, by.x = "Sample.ID", by.y = "Column", all.x = TRUE)

write_tsv(dataset_merged, "report.pg_matrix_long.tsv")
```

## Data Analysis

```{r}
# Count the number of non-NA maxLfQ_intensities for each Sample.ID within each Method
dataset_count <- dataset_merged[!is.na(maxLfQ_intensities), .(Protein_Count = .N), by = .(Method, Sample.ID, Buffer_type)]

# Set the order of Sample.ID in dataset_count to match the order in ordered_meta_data$Column
dataset_count$Sample.ID <- factor(dataset_count$Sample.ID, levels = ordered_meta_data$Column)

# Create the barplot
ggplot(dataset_count, aes(x = Sample.ID, y = Protein_Count, fill = Buffer_type)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  facet_wrap(~ Method, scales = "free_x") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Number of Quantified Proteins per Sample, by Method",
       y = "Number of Quantified Proteins", x = "Sample ID", fill = "Buffer Type") +
  scale_fill_manual(values = fraction_colors)
```


```{r}
# Filter dataset for Repl_Techn == 1 before analysis
dataset_filtered <- dataset_merged[Repl_Techn == 1 & !is.na(maxLfQ_intensities)]

# Calculate the total number of unique proteins per method for Repl_Techn == 1
unique_protein_count <- dataset_filtered[, .(Count = uniqueN(ID)), by = .(Method)]
unique_protein_count[, Source := "Total_Quantified_Proteins"]

# Calculate proteins in at least 3 out of 4 biological replicates per method for Repl_Techn == 1
proteins_in_3_of_4_repl_count <- dataset_filtered[, .(Unique_Repl_Biol_Count = uniqueN(Repl_Biol)), by = .(Method, ID)]
proteins_in_3_of_4_repl_count <- proteins_in_3_of_4_repl_count[Unique_Repl_Biol_Count >= 3, .(Count = .N), by = .(Method)]
proteins_in_3_of_4_repl_count[, Source := "Total_Proteins_3_4_Repls"]

# Combine both counts for plotting
combined_counts <- rbind(unique_protein_count, proteins_in_3_of_4_repl_count)

# Create the barplot
ggplot(combined_counts, aes(x = Method, y = Count, fill = Source)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9)) +
  geom_text(aes(label = Count), vjust = -0.3, position = position_dodge(width = 0.9), size = 3) +
  labs(title = "Protein Counts per Method (Technical Replicate 1)", 
       y = "No. of quantified proteins", 
       x = "Method", 
       fill = "Quantified Proteins") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_y_continuous(breaks = seq(0, 6000, by = 1000), limits = c(0, 6000)) +
  scale_fill_manual(values = c("Total_Quantified_Proteins" = "#4D8DB4", "Total_Proteins_3_4_Repls" = "#005B7F"),
                    labels = c("3 of 4 biol. Replicates", "Total"))

```

### Check all Techn. Replicates for Step2+

```{r}
# Combine Method and Repl_Techn
dataset_merged$Method_Techn <- paste(dataset_merged$Method, dataset_merged$Repl_Techn, sep = "_")

# Calculate the total number of unique proteins per combined Method and Repl_Techn
unique_protein_count <- dataset_merged[!is.na(maxLfQ_intensities), .(Count = uniqueN(ID)), by = .(Method_Techn)]
unique_protein_count[, Source := "Total_Quantified_Proteins"]

# Calculate proteins in at least 3 out of 4 biological replicates per combined Method and Repl_Techn
proteins_in_3_of_4_repl_count <- dataset_merged[!is.na(maxLfQ_intensities), .(Unique_Repl_Biol_Count = uniqueN(Repl_Biol)), by = .(Method_Techn, ID)]
proteins_in_3_of_4_repl_count <- proteins_in_3_of_4_repl_count[Unique_Repl_Biol_Count >= 3, .(Count = .N), by = .(Method_Techn)]
proteins_in_3_of_4_repl_count[, Source := "Total_Proteins_3_4_Repls"]

# Combine both counts for plotting
combined_counts <- rbind(unique_protein_count, proteins_in_3_of_4_repl_count)

# Create the barplot
ggplot(combined_counts, aes(x = Method_Techn, y = Count, fill = Source)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9)) +
  geom_text(aes(label = Count), vjust = -0.3, position = position_dodge(width = 0.9), size = 3) +
  labs(title = "Protein Counts per Combined Method and Technical Replicate", 
       y = "Number of Quantified Proteins", 
       x = "Method and Technical Replicate", 
       fill = "Quantified Proteins") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_y_continuous(breaks = seq(0, max(combined_counts$Count), by = 1000)) +
  scale_fill_manual(values = c("Total_Quantified_Proteins" = "#4D8DB4", "Total_Proteins_3_4_Repls" = "#005B7F"),
                    labels = c("3 of 4 Biol. Replicates", "Total"))
```



```{r}

# Filter dataset for "2step+" method
dataset_2step_plus <- dataset_merged[Method == "2step+" & !is.na(maxLfQ_intensities)]

# Filter IDs present in at least 3 out of 4 biological replicates
filtered_ids <- dataset_2step_plus[, .(Unique_Repl_Biol_Count = uniqueN(Repl_Biol)), by = .(ID)]
filtered_ids <- filtered_ids[Unique_Repl_Biol_Count >= 3]
dataset_2step_plus <- merge(filtered_ids[, .(ID)], dataset_2step_plus, by = "ID")

binary_presence <- dataset_2step_plus %>%
  distinct(ID, Repl_Techn) %>%
  pivot_wider(names_from = Repl_Techn, values_from = Repl_Techn, 
              values_fill = list(Repl_Techn = 0), 
              values_fn = list(Repl_Techn = function(x) 1))  %>%
  tibble::column_to_rownames(var = "ID")

binary_presence$all <- 1
binary_presence <- binary_presence[, c(4,3,2,1,5)]

ComplexUpset::upset(data=binary_presence, 
                    intersect=names(binary_presence), name="Technical Replicates", 
                     wrap=TRUE,
                    base_annotations=list(
                        'Intersection size'=intersection_size(
                            text=list(
                                size = 2.5
                            )
                        )
                    ),
                    set_sizes=(
                        upset_set_size()
                        + geom_text(aes(label=..count..), hjust=1.1, stat='count')
                        + annotate(geom='text', label='@', x='Count', y=850, color='white', size=3)
                        + expand_limits(y=7000)
                    ),
                    sort_sets=FALSE,
                    queries=list(
                        upset_query(
                            intersect = names(binary_presence),
                            color='darkred',
                            fill='darkred',
                            only_components=c('intersections_matrix', 'Intersection size')
                        ),
                        upset_query(
                            set='all',
                            fill='orange'
                        ), 
                        upset_query(intersect = c("all", "1"), color = "darkgreen", only_components=c('intersections_matrix')),
                        upset_query(intersect = c("all", "2"), color = "darkgreen", only_components=c('intersections_matrix')),
                        upset_query(intersect = c("all", "3"), color = "darkgreen", only_components=c('intersections_matrix')),
                        upset_query(intersect = c("all", "4"), color = "darkgreen", only_components=c('intersections_matrix'))
                    ),
                    sort_intersections_by='degree') + ggtitle('Intersection of Quantified Proteins in 2Step+')

```

```{r}
# Filter dataset for Repl_Techn == 1 before analysis
dataset_filtered <- dataset_merged[!is.na(maxLfQ_intensities)]

# Calculate the total number of unique proteins per method for Repl_Techn == 1
unique_protein_count <- dataset_filtered[, .(Count = uniqueN(ID)), by = .(Method)]
unique_protein_count[, Source := "Total_Quantified_Proteins"]

# Calculate proteins in at least 3 out of 4 biological replicates per method for Repl_Techn == 1
proteins_in_3_of_4_repl_count <- dataset_filtered[, .(Unique_Repl_Biol_Count = uniqueN(Repl_Biol)), by = .(Method, ID)]
proteins_in_3_of_4_repl_count <- proteins_in_3_of_4_repl_count[Unique_Repl_Biol_Count >= 3, .(Count = .N), by = .(Method)]
proteins_in_3_of_4_repl_count[, Source := "Total_Proteins_3_4_Repls"]

# Combine both counts for plotting
combined_counts <- rbind(unique_protein_count, proteins_in_3_of_4_repl_count)

# Create the barplot
ggplot(combined_counts, aes(x = Method, y = Count, fill = Source)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9)) +
  geom_text(aes(label = Count), vjust = -0.3, position = position_dodge(width = 0.9), size = 3) +
  labs(title = "Protein Counts per Method (Technical Replicate 1)", 
       y = "No. of quantified proteins", 
       x = "Method", 
       fill = "Quantified Proteins") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_y_continuous(breaks = seq(0, 6000, by = 1000), limits = c(0, 6000)) +
  scale_fill_manual(values = c("Total_Quantified_Proteins" = "#4D8DB4", "Total_Proteins_3_4_Repls" = "#005B7F"),
                    labels = c("3 of 4 biol. Replicates", "Total"))
```

### Intersection of all methods

```{r}

# Filter dataset for Repl_Techn == 1 and not NA in maxLfQ_intensities
dataset_techn_1 <- dataset_merged[Repl_Techn == 1 & !is.na(maxLfQ_intensities)]

# Filter IDs present in at least 3 out of 4 biological replicates
filtered_ids <- dataset_techn_1[, .(Unique_Repl_Biol_Count = uniqueN(Repl_Biol)), by = .(Method, ID)]
filtered_ids <- filtered_ids[Unique_Repl_Biol_Count >= 3]
dataset_techn_1 <- merge(filtered_ids[, .(Method, ID)], dataset_techn_1, by = c("Method", "ID"))

# Creating a binary presence table for each protein ID across methods
binary_presence <- dataset_techn_1 %>%
  distinct(ID, Method) %>%
  pivot_wider(names_from = Method, values_from = Method, 
              values_fill = list(Method = 0), 
              values_fn = list(Method = function(x) 1)) %>%
  tibble::column_to_rownames(var = "ID")

binary_presence$all <- 1
binary_presence <- binary_presence[, c("4step", "2step+", "2step", "1step+", "1step", "all")]

ComplexUpset::upset(data=binary_presence, 
                    intersect=names(binary_presence), name="Methods", 
                     wrap=TRUE,
                    base_annotations=list(
                        'Intersection size'=intersection_size(
                            text=list(
                                size = 2.5
                            )
                        )
                    ),
                    set_sizes=(
                        upset_set_size()
                        + geom_text(aes(label=..count..), hjust=1.1, stat='count')
                        + annotate(geom='text', label='@', x='Count', y=850, color='white', size=3)
                        + expand_limits(y=7000)
                    ),
                    sort_sets=FALSE,
                    queries=list(
                        upset_query(
                            intersect = names(binary_presence),
                            color='darkred',
                            fill='darkred',
                            only_components=c('intersections_matrix', 'Intersection size')
                        ),
                        upset_query(
                            set='all',
                            fill='orange'
                        ), 
                        upset_query(intersect = c("all", "1step"), color = "darkgreen", only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("all", "1step+"), color = "darkgreen", only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("all", "2step"), color = "darkgreen", only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("all", "2step+"), color = "darkgreen", only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("all", "4step"), color = "darkgreen", only_components=c('intersections_matrix', 'Intersection size'))
                    ),
                    sort_intersections_by='cardinality') + ggtitle('Intersection of Quantified Proteins in Methods')
```

```{r}
library(VennDiagram) 

# Filter the dataset for the specified methods and technical replicate 1
#filtered_dataset <- dataset_merged %>%
filtered_dataset <- dataset_techn_1 %>%
  filter(Method %in% c("2step", "2step+", "4step") & Repl_Techn == 1 & !is.na(maxLfQ_intensities))
  

# Get unique IDs for each method
ids_2step <- unique(filtered_dataset$ID[filtered_dataset$Method == "2step"])
ids_2step_plus <- unique(filtered_dataset$ID[filtered_dataset$Method == "2step+"])
ids_4step <- unique(filtered_dataset$ID[filtered_dataset$Method == "4step"])

# Define a list with IDs for each method
list_of_ids <- list(
  "2step" = ids_2step,
  "2step+" = ids_2step_plus,
  "4step" = ids_4step
)

# Create the Venn diagram
venn.plot <- venn.diagram(
  x = list_of_ids,
  category.names = c("2step", "2step+", "4step"),
  output = TRUE,
  filename = NULL
)

# Plotting
grid.draw(venn.plot)

```

```{r}
# Filter dataset for technical replicate 1 and not NA in maxLfQ_intensities
dataset_filtered <- dataset_merged[Method %in% c("2step", "2step+", "4step") & Repl_Techn == 1 & !is.na(maxLfQ_intensities), ]

# Get unique IDs for each method
ids_2step <- unique(dataset_filtered$ID[dataset_filtered$Method == "2step"])
ids_2step_plus <- unique(dataset_filtered$ID[dataset_filtered$Method == "2step+"])
ids_4step <- unique(dataset_filtered$ID[dataset_filtered$Method == "4step"])

# Find exclusive IDs for each method
exclusive_ids_2step <- setdiff(ids_2step, c(ids_2step_plus, ids_4step))
exclusive_ids_2step_plus <- setdiff(ids_2step_plus, c(ids_2step, ids_4step))
exclusive_ids_4step <- setdiff(ids_4step, c(ids_2step, ids_2step_plus))

# Create dataframes for exclusive IDs
exclusive_df_2step <- dataset_filtered[dataset_filtered$ID %in% exclusive_ids_2step, ]
exclusive_df_2step_plus <- dataset_filtered[dataset_filtered$ID %in% exclusive_ids_2step_plus, ]
exclusive_df_4step <- dataset_filtered[dataset_filtered$ID %in% exclusive_ids_4step, ]

# Combine into one dataframe
exclusive_df_combined <- rbind(exclusive_df_2step, exclusive_df_2step_plus, exclusive_df_4step)

exclusive_df_refined <- exclusive_df_combined %>%
  select(Protein.Ids, Protein.Names, Genes, ID, First.Protein.Description, Method) %>%
  distinct()
```


## Check Intersection between Buffers

```{r}
dataset_4step <- dataset_techn_1[dataset_techn_1$Method == "4step",]

binary_presence <- dataset_4step %>%
  distinct(ID, Buffer_name) %>%
  pivot_wider(names_from = Buffer_name, values_from = Buffer_name, 
              values_fill = list(Buffer_name = 0), 
              values_fn = list(Buffer_name = function(x) 1))  %>%
  tibble::column_to_rownames(var = "ID")

binary_presence$all <- 1
binary_presence <- binary_presence[, c("AS2", "AI2", "AI1", "AS1", "all")]

ComplexUpset::upset(data=binary_presence, 
                    intersect=names(binary_presence), name="Technical Replicates", 
                     wrap=TRUE,
                    base_annotations=list(
                        'Intersection size'=intersection_size(
                            text=list(
                                size = 2.5
                            )
                        )
                    ),
                    set_sizes=(
                        upset_set_size()
                        + geom_text(aes(label=..count..), hjust=1.1, stat='count')
                        + annotate(geom='text', label='@', x='Count', y=850, color='white', size=3)
                        + expand_limits(y=7000)
                    ),
                    sort_sets=FALSE,
                    queries=list(
                        upset_query(
                            intersect = c("AI2", "AS2", "all"),
                            color='orchid',,
                            only_components=c('intersections_matrix')
                        ),
                        upset_query(
                            intersect = c("AI2", "all"),
                            color='orchid',,
                            only_components=c('intersections_matrix')
                        ),
                        upset_query(
                            intersect = c("AS2", "all"),
                            color='orchid',,
                            only_components=c('intersections_matrix')
                        ),
                        upset_query(
                            set='all',
                            fill='orange'
                        )
                    ),
                    sort_intersections_by='cardinality') + ggtitle('Intersection of Quantified Proteins in Buffers for 4Step')
```


```{r}
check_df <- subset(binary_presence, (all == 1 & AS2 == 1 & AI2 == 1 & AI1 == 0 & AS1 == 0) |
         (all == 1 & AS2 == 1 & AI2 == 0 & AI1 == 0 & AS1 == 0) |
         (all == 1 & AS2 == 0 & AI2 == 1 & AI1 == 0 & AS1 == 0))

check_df2 <- dataset_sorted[dataset_sorted$ID %in% rownames(check_df)]

```

# GO Terms

```{r}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("clusterProfiler")
BiocManager::install("org.Rn.eg.db")  # Rat gene database

library(dplyr)
library(clusterProfiler)
library(org.Rn.eg.db)


# Split data based on 'Method'
list_of_dataframes <- split(dataset_techn_1, dataset_techn_1$Method)

# Function to process genes and create unique vectors
process_genes <- function(df) {
  # Split genes and unlist into a single long vector
  genes_split <- strsplit(as.character(df$Genes), ";")
  unique_genes <- unique(unlist(genes_split))
  return(unique_genes)
}

# Apply function to each dataframe
list_of_gene_vectors <- lapply(list_of_dataframes, process_genes)

```

## Randomize 

```{r}
all_gene_ids <- keys(org.Rn.eg.db, keytype = "SYMBOL")

generate_random_gene_vectors <- function(original_list, all_genes) {
  random_list <- lapply(original_list, function(vector) {
    vector_size <- length(vector)  # Get the size of the original vector
    random_genes <- sample(all_genes, vector_size)  # Randomly pick genes
    setNames(random_genes, names(vector))  # Keep original names, replace values
  })
  return(random_list)
}

# Create random list of gene vectors
random_list_of_gene_vectors <- generate_random_gene_vectors(list_of_gene_vectors, all_gene_ids)
```

## Enrichment

```{r}
# Set up enrichment analysis parameters
keytype <- "SYMBOL"  # Assuming gene symbols are used
universe <- keys(org.Rn.eg.db, keytype)

# Function to perform GO analysis
run_go_enrichment <- function(genes) {
  # Create an enriched GO object
  ego <- enrichGO(gene          = genes,
                  universe      = universe,
                  OrgDb         = org.Rn.eg.db,
                  keyType       = keytype,
                  ont           = "BP",  # Biological Process
                  pAdjustMethod = "BH",
                  qvalueCutoff  = 1)
  return(ego)
}

# Apply GO enrichment to each gene vector
results_go_enrichment <- lapply(list_of_gene_vectors, run_go_enrichment)

# Apply GO enrichment to each gene vector
random_results_go_enrichment <- lapply(random_list_of_gene_vectors, run_go_enrichment)
```

```{r}
# Function to filter existing enrichment results
filter_go_results <- function(enrich_result) {
  # Check if the object has results and filter
  df <- data.frame(enrich_result@result)
  if (length(df) > 0) {  # Ensure there are results to filter
    #filtered_results <- df[df$p.adjust < 0.05, ]
    filtered_results <- df[df$pvalue < 0.05, ]
    return(filtered_results)
  } else {
    return(data.frame())  # Return an empty data.frame if no results
  }
}

# Apply the filtering function to each set of enrichment results
filtered_results_go_enrichment <- lapply(results_go_enrichment, filter_go_results)
filtered_random_results_go_enrichment <- lapply(random_results_go_enrichment, filter_go_results)
```

## Visualization

### Regular 

```{r}
# Function to extract GO term IDs from results
extract_go_ids <- function(df) {
  if (nrow(df) > 0) {  # Check if dataframe is not empty
    return(df$ID)
  } else {
    return(character(0))  # Return empty character vector if no GO terms
  }
}

# Extract GO term IDs from each filtered result
list_of_go_ids <- lapply(filtered_results_go_enrichment, extract_go_ids)

# Assuming list_of_go_ids is available and named per method or condition
names(list_of_go_ids) <- names(filtered_results_go_enrichment)  # Ensure names are properly assigned

# Combine all GO term IDs into a single dataframe
all_go_ids <- unique(unlist(list_of_go_ids))
binary_matrix <- sapply(list_of_go_ids, function(ids) as.integer(all_go_ids %in% ids))

# Convert to dataframe for UpSetR
binary_df <- data.frame(binary_matrix, row.names = all_go_ids)

names(binary_df) <- names(filtered_results_go_enrichment)
```

```{r}
ComplexUpset::upset(data=binary_df, 
                    intersect=names(binary_df), name="Extraction Methods", 
                     wrap=TRUE,
                    base_annotations=list(
                        'Intersection size'=intersection_size(
                            text=list(
                                size = 2.5
                            )
                        )
                    ),
                    set_sizes=(
                        upset_set_size()
                        + geom_text(aes(label=..count..), hjust=1.1, stat='count')
                        + annotate(geom='text', label='@', x='Count', y=850, color='white', size=3)
                        + expand_limits(y=7000)
                    ),
                    sort_sets=FALSE,
                    queries=list(
                        upset_query(intersect = c("1step"), color = "orchid", fill='orchid', only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("1step+"), color = "orchid", fill='orchid', only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("2step"), color = "orchid", fill='orchid', only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("2step+"), color = "orchid", fill='orchid', only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("4step"), color = "orchid", fill='orchid', only_components=c('intersections_matrix', 'Intersection size'))
                    ),
                    sort_intersections_by='cardinality') + ggtitle('Intersection of Biological Processes (BP) GO Terms in Extraction Methods')
```
### Random 

```{r}
# Function to extract GO term IDs from results
extract_go_ids <- function(df) {
  if (nrow(df) > 0) {  # Check if dataframe is not empty
    return(df$ID)
  } else {
    return(character(0))  # Return empty character vector if no GO terms
  }
}

# Extract GO term IDs from each filtered result
list_of_go_ids <- lapply(filtered_random_results_go_enrichment, extract_go_ids)

# Assuming list_of_go_ids is available and named per method or condition
names(list_of_go_ids) <- names(filtered_random_results_go_enrichment)  # Ensure names are properly assigned

# Combine all GO term IDs into a single dataframe
all_go_ids <- unique(unlist(list_of_go_ids))
binary_matrix <- sapply(list_of_go_ids, function(ids) as.integer(all_go_ids %in% ids))

# Convert to dataframe for UpSetR
binary_df <- data.frame(binary_matrix, row.names = all_go_ids)

names(binary_df) <- names(filtered_random_results_go_enrichment)
```

```{r}
ComplexUpset::upset(data=binary_df, 
                    intersect=names(binary_df), name="Extraction Methods", 
                     wrap=TRUE,
                    base_annotations=list(
                        'Intersection size'=intersection_size(
                            text=list(
                                size = 2.5
                            )
                        )
                    ),
                    set_sizes=(
                        upset_set_size()
                        + geom_text(aes(label=..count..), hjust=1.1, stat='count')
                        + annotate(geom='text', label='@', x='Count', y=850, color='white', size=3)
                        + expand_limits(y=7000)
                    ),
                    sort_sets=FALSE,
                    queries=list(
                        upset_query(intersect = c("1step"), color = "orchid", fill='orchid', only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("1step+"), color = "orchid", fill='orchid', only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("2step"), color = "orchid", fill='orchid', only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("2step+"), color = "orchid", fill='orchid', only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("4step"), color = "orchid", fill='orchid', only_components=c('intersections_matrix', 'Intersection size'))
                    ),
                    sort_intersections_by='cardinality') + ggtitle('Intersection of Biological Processes (BP) GO Terms in Random (sizes retained)')
```

# KEGG

```{r}
library(AnnotationDbi)
# Function to convert gene symbols to Entrez IDs
convert_symbols_to_entrez <- function(gene_symbols) {
  mapped_ids <- select(org.Rn.eg.db, keys = gene_symbols, columns = "ENTREZID", keytype = "SYMBOL")
  # Filter out not found mappings and duplicates
  valid_ids <- na.omit(mapped_ids$ENTREZID)
  return(unique(valid_ids))
}

# Convert gene vectors
list_of_entrez_ids <- lapply(list_of_gene_vectors, convert_symbols_to_entrez)
random_list_of_entrez_ids <- lapply(random_list_of_gene_vectors, convert_symbols_to_entrez)
```


```{r}
# Set up KEGG enrichment analysis parameters
keytype <- "ncbi-geneid"  # Assuming gene symbols are used
#universe <- keys(org.Rn.eg.db, keytype)

# Function to perform KEGG analysis
run_kegg_enrichment <- function(genes) {
  # Check that there are enough genes to run the analysis
  if (length(genes) < 10) {
    warning("Not enough genes for KEGG enrichment: ", length(genes))
    return(NULL)
  }

  # Create an enriched KEGG object
  kegg_result <- enrichKEGG(gene = genes,
                            organism = 'rno',  # Use 'rno' for Rattus norvegicus (rat)
                            keyType = keytype,
                            #universe = universe,
                            pAdjustMethod = "BH",
                            qvalueCutoff = 1)
  return(kegg_result)
}

# Apply KEGG enrichment to each gene vector
results_kegg_enrichment <- lapply(list_of_entrez_ids, run_kegg_enrichment)
random_results_kegg_enrichment <- lapply(random_list_of_entrez_ids, run_kegg_enrichment)
```

```{r}
# Function to filter existing enrichment results
filter_kegg_results <- function(enrich_result) {
  # Check if the object has results and filter
  df <- data.frame(enrich_result@result)
  if (length(df) > 0) {  # Ensure there are results to filter
    #filtered_results <- df[df$p.adjust < 0.05, ]
    filtered_results <- df[df$pvalue < 0.05, ]
    return(filtered_results)
  } else {
    return(data.frame())  # Return an empty data.frame if no results
  }
}

# Apply the filtering function to each set of enrichment results
filtered_results_kegg_enrichment <- lapply(results_kegg_enrichment, filter_kegg_results)
filtered_random_results_kegg_enrichment <- lapply(random_results_kegg_enrichment, filter_kegg_results)
```

## Visualize

### Regular 

```{r}
# Function to extract GO term IDs from results
extract_kegg_ids <- function(df) {
  if (nrow(df) > 0) {  # Check if dataframe is not empty
    return(df$ID)
  } else {
    return(character(0))  # Return empty character vector if no GO terms
  }
}

# Extract GO term IDs from each filtered result
list_of_kegg_ids <- lapply(filtered_results_kegg_enrichment, extract_kegg_ids)

# Assuming list_of_go_ids is available and named per method or condition
names(list_of_kegg_ids) <- names(filtered_results_kegg_enrichment)  # Ensure names are properly assigned

# Combine all GO term IDs into a single dataframe
all_kegg_ids <- unique(unlist(list_of_kegg_ids))
binary_matrix <- sapply(list_of_kegg_ids, function(ids) as.integer(all_kegg_ids %in% ids))

# Convert to dataframe for UpSetR
binary_df <- data.frame(binary_matrix, row.names = all_kegg_ids)

names(binary_df) <- names(filtered_results_kegg_enrichment)
```

```{r}
ComplexUpset::upset(data=binary_df, 
                    intersect=names(binary_df), name="Extraction Methods", 
                     wrap=TRUE,
                    base_annotations=list(
                        'Intersection size'=intersection_size(
                            text=list(
                                size = 2.5
                            )
                        )
                    ),
                    set_sizes=(
                        upset_set_size()
                        + geom_text(aes(label=..count..), hjust=1.1, stat='count')
                        + annotate(geom='text', label='@', x='Count', y=850, color='white', size=3)
                        + expand_limits(y=7000)
                    ),
                    sort_sets=FALSE,
                    queries=list(
                        upset_query(intersect = c("1step"), color = "orchid", fill='orchid', only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("1step+"), color = "orchid", fill='orchid', only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("2step"), color = "orchid", fill='orchid', only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("2step+"), color = "orchid", fill='orchid', only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("4step"), color = "orchid", fill='orchid', only_components=c('intersections_matrix', 'Intersection size'))
                    ),
                    sort_intersections_by='cardinality') + ggtitle('Intersection of KEGG Terms in Extraction Methods')
```
### Random 

```{r}
# Function to extract GO term IDs from results
extract_kegg_ids <- function(df) {
  if (nrow(df) > 0) {  # Check if dataframe is not empty
    return(df$ID)
  } else {
    return(character(0))  # Return empty character vector if no GO terms
  }
}

# Extract GO term IDs from each filtered result
list_of_kegg_ids <- lapply(filtered_random_results_kegg_enrichment, extract_kegg_ids)

# Assuming list_of_go_ids is available and named per method or condition
names(list_of_kegg_ids) <- names(filtered_random_results_kegg_enrichment)  # Ensure names are properly assigned

# Combine all GO term IDs into a single dataframe
all_kegg_ids <- unique(unlist(list_of_kegg_ids))
binary_matrix <- sapply(list_of_kegg_ids, function(ids) as.integer(all_kegg_ids %in% ids))

# Convert to dataframe for UpSetR
binary_df <- data.frame(binary_matrix, row.names = all_kegg_ids)

names(binary_df) <- names(filtered_random_results_kegg_enrichment)
```

```{r}
ComplexUpset::upset(data=binary_df, 
                    intersect=names(binary_df), name="Extraction Methods", 
                     wrap=TRUE,
                    base_annotations=list(
                        'Intersection size'=intersection_size(
                            text=list(
                                size = 2.5
                            )
                        )
                    ),
                    set_sizes=(
                        upset_set_size()
                        + geom_text(aes(label=..count..), hjust=1.1, stat='count')
                        + annotate(geom='text', label='@', x='Count', y=850, color='white', size=3)
                        + expand_limits(y=7000)
                    ),
                    sort_sets=FALSE,
                    queries=list(
                        upset_query(intersect = c("1step"), color = "orchid", fill='orchid', only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("1step+"), color = "orchid", fill='orchid', only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("2step"), color = "orchid", fill='orchid', only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("2step+"), color = "orchid", fill='orchid', only_components=c('intersections_matrix', 'Intersection size')),
                        upset_query(intersect = c("4step"), color = "orchid", fill='orchid', only_components=c('intersections_matrix', 'Intersection size'))
                    ),
                    sort_intersections_by='cardinality') + ggtitle('Intersection of KEGG Terms in Random (sizes retained)')
```



### Inspection

```{r}
# Step 1: Extract KEGG pathway IDs from each enrichment result
kegg_pathway_ids <- lapply(results_kegg_enrichment, function(x) {
  if (!is.null(x) && "enrichResult" %in% class(x)) {
    return(as.character(x$ID))  # Extracting KEGG pathway IDs
  } else {
    return(character(0))  # Return empty character vector if result is NULL or not an enrichResult
  }
})

# Step 2: Find unique pathways in "4step" compared to others
other_kegg_ids <- unlist(kegg_pathway_ids[names(kegg_pathway_ids) != "2step"])  # Combine all but "4step"
unique_4step_ids <- setdiff(kegg_pathway_ids[["2step"]], other_kegg_ids)  # Find unique pathways

test <- filtered_results_kegg_enrichment[["2step"]][filtered_results_kegg_enrichment[["2step"]]$ID %in% unique_4step_ids,]
```

```{r}
# Step 1: Combine dataframes and retain only the pathway IDs common to all dataframes
common_ids <- Reduce(intersect, lapply(filtered_results_kegg_enrichment, function(df) df$ID))
combined_df <- bind_rows(lapply(names(filtered_results_kegg_enrichment), function(name) {
  df <- filtered_results_kegg_enrichment[[name]]
  df <- df %>% filter(ID %in% common_ids) %>%
               mutate(Source = name) %>%
               dplyr::select(ID, Description, p.adjust, Source)
  df
}), .id = "DataFrame")

# Step 2: Calculate mean adjusted p-value for each pathway and select the top 15
top_common_terms <- combined_df %>%
  group_by(ID, Description) %>%
  summarize(MeanPValue = mean(p.adjust), .groups = 'drop') %>%
  arrange(MeanPValue) %>%
  slice_head(n = 15)

# Step 3: Join back to get individual dataframe p-values for these top pathways
plot_data <- left_join(combined_df, top_common_terms[, !names(top_common_terms) %in% "Description"], by = "ID")

plot_data <- plot_data %>%
  filter(!is.na(MeanPValue)) %>%
  arrange(desc(MeanPValue)) %>%
  mutate(Description = factor(Description, levels = unique(Description)))

# Step 4: Create the dot plot with adjusted p-values for the top 15 pathways
ggplot(plot_data, aes(x = Description, y = -log10(p.adjust), color = Source)) +
  geom_point(position = position_dodge(width = 0.25), size = 3) +
  scale_color_brewer(palette = "Set1") +  # Using a qualitative palette
  labs(title = "Top 15 Common KEGG Pathways Across Dataframes\nBased on Mean Adjusted P-Value",
       x = "Pathway",
       y = "-log10(Adjusted P-Value)") +
  coord_flip() +  # Flips the axes for horizontal orientation
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))  
```

### TMP

```{r}
library(jsonlite)
file_path <- "clusters_genes.json" 
json_data <- fromJSON(file_path)
```

```{r}
# Set up enrichment analysis parameters
keytype <- "SYMBOL"  # Assuming gene symbols are used
universe <- keys(org.Rn.eg.db, keytype)

# Function to perform GO analysis
run_go_enrichment <- function(genes) {
  # Create an enriched GO object
  ego <- enrichGO(gene          = genes,
                  universe      = universe,
                  OrgDb         = org.Rn.eg.db,
                  keyType       = keytype,
                  ont           = "MF", 
                  pAdjustMethod = "BH",
                  qvalueCutoff  = 1)
  return(ego)
}

# Apply GO enrichment to each gene vector
json_go_enrichment <- lapply(json_data, run_go_enrichment)
```

```{r}
pls <- list()
# Function to create and save a dotplot for each GO enrichment result
create_and_save_dotplot <- function(ego, title) {
  if (is.null(ego) || length(ego) == 0) {
    cat("No significant GO terms found for", title, "\n")
    return()  # Skip if no results
  }

  # Create the plot
  plot <- dotplot(ego, showCategory = 30) + 
    ggtitle(paste("Dotplot for GO Terms - MF -", title))

  # Assign plot to global list for potential later use
  pls[[title]] <<- plot

  # Save the plot to a file
  file_name <- paste0(gsub(" ", "_", title), "_GO_MF_dotplot.png")
  ggsave(file_name, plot, width = 10, height = 8)
}

# Apply the function to each enrichment result
lapply(names(json_go_enrichment), function(name) {
  create_and_save_dotplot(json_go_enrichment[[name]], name)
})

```

## Stack Plot

```{r}
# Filter dataset for Repl_Techn == 1 and not NA in maxLfQ_intensities
dataset_techn_1 <- dataset_merged[Repl_Techn == 1 & !is.na(maxLfQ_intensities)]

# Filter IDs present in at least 3 out of 4 biological replicates
filtered_ids <- dataset_techn_1[, .(Unique_Repl_Biol_Count = uniqueN(Repl_Biol)), by = .(Method, ID)]
filtered_ids <- filtered_ids[Unique_Repl_Biol_Count >= 3]
dataset_techn_1 <- merge(filtered_ids[, .(Method, ID)], dataset_techn_1, by = c("Method", "ID"))
```

```{r}
# Your data frame example (replace this with your actual data frame loading line)
# dataset_techn_1 <- data.frame(Method = c("4step", "2step+", "1step"), Buffer = c("AS1", "AS", "single"), ID = sample(1:100, 20))

# Define the order of buffers for each method
buffer_order <- list(
  `4step` = c("AS1", "AI1", "AI2", "AS2"),
  `2step+` = c("AS", "AI"),
  `2step` = c("AS", "AI"),
  `1step+` = c("single"),
  `1step` = c("single")
)

# Step 1: Group by Method and Buffer, count unique IDs
method_buffer_ids <- dataset_techn_1 %>%
  group_by(Method, Buffer_name) %>%
  summarise(IDs = list(unique(ID)), .groups = 'drop')

# Step 2: Calculate new IDs added for each buffer in order
new_ids_by_method <- lapply(names(buffer_order), function(method) {
  # Subset data for the method
  subset_data <- method_buffer_ids %>%
    filter(Method == method) %>%
    arrange(match(Buffer_name, buffer_order[[method]]))  # Arrange by the specified buffer order

  # Compute cumulative union of IDs and new IDs at each step
  cumulative_ids <- list()
  new_ids_count <- c()
  
  for (i in seq_along(subset_data$Buffer_name)) {
    current_ids <- subset_data$IDs[[i]]
    if (i == 1) {
      cumulative_ids[[i]] <- unique(current_ids)
      new_ids_count[i] <- length(current_ids)
    } else {
      cumulative_ids[[i]] <- unique(union(cumulative_ids[[i - 1]], current_ids))
      new_ids_count[i] <- length(cumulative_ids[[i]]) - length(cumulative_ids[[i - 1]])
    }
  }
  
  data.frame(
    Buffer_name = subset_data$Buffer_name,
    CumulativeIDCount = sapply(cumulative_ids, length),
    NewIDsAdded = new_ids_count
  )
})
new_ids_by_method <- setNames(new_ids_by_method, names(buffer_order))
# Print or return results
new_ids_by_method
```

```{r}
# Combine all data frames into one, adding a 'Method' column to each
combined_data <- bind_rows(lapply(names(new_ids_by_method), function(method) {
  df <- new_ids_by_method[[method]]
  df$Method <- method
  df
}), .id = NULL)

# Ensure Buffer is factored correctly according to buffer_orders
combined_data <- combined_data %>%
  mutate(Buffer = as.character(Buffer_name)) %>%  # Ensure Buffer is character to reset factor levels
  group_by(Method) %>%
  mutate(Buffer = factor(Buffer, levels = buffer_order[[unique(Method)]]))

# Assign color mapping based on general buffer type
fraction_colors <- c("AI" = "royalblue", "AS" = "palegreen3", "single" = "coral")
combined_data$BufferType <- ifelse(grepl("AI", combined_data$Buffer), "AI",
                                   ifelse(grepl("AS", combined_data$Buffer), "AS", "single"))

#combined_data$NewIDsAdded <- factor(combined_data$NewIDsAdded, levels=(combined_data$NewIDsAdded))

# Create the stacked bar plot with the correct buffer order
ggplot(combined_data, aes(x = Method, y = NewIDsAdded, fill = BufferType)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_fill_manual(values = fraction_colors) +
  geom_text(aes(label = NewIDsAdded), position = position_stack(vjust = 0.5), size = 3) +
  labs(title = "New IDs Added per Method and Buffer Type", x = "Method", y = "New IDs Added") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
#df <- dataset_filtered
df <- dataset_techn_1

# Calculate the max LFQ intensities for each sample type with 4 biological replicates
max_lfq_df <- df %>%
  group_by(Protein.Group, Genes, Method, Buffer_name) %>%
  summarize(MaxLFQ = max(maxLfQ_intensities, na.rm = TRUE)) %>%
  ungroup()

# Calculate the statistics for each sample type
stats_df <- df %>%
  group_by(Protein.Group, Genes, Method, Buffer_name) %>%
  summarize(
    MeanLFQ = mean(maxLfQ_intensities, na.rm = TRUE),
    SDLFQ = sd(maxLfQ_intensities, na.rm = TRUE),
    CVLFQ = (sd(maxLfQ_intensities, na.rm = TRUE) / mean(maxLfQ_intensities, na.rm = TRUE)) * 100,
    .groups = 'drop'
  ) %>%
  filter(!is.na(MeanLFQ))  # Remove rows where mean LFQ is NA

# Combine the max LFQ intensities and statistics
combined_df <- max_lfq_df %>%
  left_join(stats_df, by = c("Protein.Group", "Genes", "Method", "Buffer_name")) %>%
  arrange(Protein.Group, Genes, Method, Buffer_name)
```

## Buffer vs Buffer

```{r}
dataset_techn_1_step2 <- dataset_techn_1[dataset_techn_1$Method == "2step",]

library(data.table)
library(ggplot2)

# Assuming dataset_techn_1_step2 is already loaded as a data.table

# Step 1: Calculate the mean intensity for each ID for each Buffer_name
mean_intensities <- dataset_techn_1_step2[, .(mean_intensity = mean(maxLfQ_intensities)), by = .(ID, Buffer_name)]

# Step 2: Generate the plots

# 1. Boxplot with Buffer_name on the x-axis and the mean intensities on the y-axis
ggplot(mean_intensities, aes(x = Buffer_name, y = mean_intensity)) +
  geom_boxplot(fill = "#56B4E9", color = "black") +
  labs(title = "Mean Intensities by Buffer Name",
       x = "Buffer Name",
       y = "Mean Intensity") +
  theme_minimal()

# Determine unique and shared IDs
buffer_groups <- dataset_techn_1_step2[, .N, by = .(ID, Buffer_name)]
unique_ids <- buffer_groups[, .(unique_count = .N), by = .(ID)][unique_count == 1, .(ID)]
shared_ids <- buffer_groups[, .(shared_count = .N), by = .(ID)][shared_count > 1, .(ID)]

# Combine unique and shared counts per Buffer_name
unique_counts <- buffer_groups[ID %in% unique_ids$ID, .N, by = Buffer_name]
shared_counts <- buffer_groups[ID %in% shared_ids$ID, .N, by = Buffer_name]

# Create data for boxplot 2
unique_shared_data <- rbind(
  data.table(Buffer_name = unique_counts$Buffer_name, count = unique_counts$N, Type = "Unique"),
  data.table(Buffer_name = shared_counts$Buffer_name, count = shared_counts$N, Type = "Shared")
)

# 2. Boxplot showing how many IDs are unique in each Buffer_name and how many are shared
ggplot(unique_shared_data, aes(x = Buffer_name, y = count, fill = Type)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Unique and Shared IDs by Buffer Name",
       x = "Buffer Name",
       y = "Count of IDs") +
  theme_minimal()

# 3. Scatterplot for IDs shared between the two Buffer_names, with intensities for each Buffer_name on the x and y axes
shared_intensities <- dcast(mean_intensities[ID %in% shared_ids$ID], ID ~ Buffer_name, value.var = "mean_intensity")

# Ensure there are exactly two Buffer_names for scatterplot
ggplot(shared_intensities, aes(x = AS, y = AI)) +
  geom_point(alpha = 0.6) +
  labs(title = "Scatterplot of Mean Intensities for Shared IDs",
       x = "AS",
       y = "AI") +
  theme_minimal()
```



```{r}
# Install and load VennDiagram package if not already installed
if (!require("VennDiagram")) {
  install.packages("VennDiagram")
}
library(VennDiagram)

# Assuming dataset_techn_1_step2 is already loaded as a data.table

# Determine unique and shared IDs
buffer_groups <- dataset_techn_1_step2[, .N, by = .(ID, Buffer_name)]
unique_ids <- buffer_groups[, .(unique_count = .N), by = .(ID)][unique_count == 1, .(ID)]
shared_ids <- buffer_groups[, .(shared_count = .N), by = .(ID)][shared_count > 1, .(ID)]

# Extract unique IDs per Buffer_name
unique_as_ids <- buffer_groups[Buffer_name == "AS" & ID %in% unique_ids$ID, ID]
unique_ai_ids <- buffer_groups[Buffer_name == "AI" & ID %in% unique_ids$ID, ID]

# Extract shared IDs
shared_ids <- shared_ids$ID

# Create a Venn diagram
venn.plot <- venn.diagram(
  x = list(
    AS = unique_as_ids,
    AI = unique_ai_ids,
    Shared = shared_ids
  ),
  category.names = c("AS", "AI", "Shared"),
  filename = NULL,
  fill = c("#56B4E9", "#D55E00", "#0072B2"),
  alpha = 0.5,
  cex = 2,
  cat.cex = 2,
  cat.pos = 0,
  cat.dist = 0.05,
  cat.col = c("#56B4E9", "#D55E00", "#0072B2"),
  margin = 0.1
)

# Display the Venn diagram
grid.draw(venn.plot)

```




